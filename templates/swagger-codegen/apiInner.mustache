/* tslint:disable */
/* eslint-disable */
{{>licenseInfo}}

// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '{{apiRelativeToRoot}}base';
{{#imports}}
import { {{import}} } from '{{apiRelativeToRoot}}{{tsModelPackage}}';
{{/imports}}
import { OAuth } from '../../oauth';
import { Http } from '../../http';
import { ConfigLoader } from '../../config-loader';
import { DefaultRequestExecutor } from '../../default-request-executor';
import { ModelFactory } from '../../model-factory';
import { Collection } from '../../collection';

import type { V2Configuration } from '../../configuration';
import type { Configuration } from '{{apiRelativeToRoot}}configuration';

const os = require('os');
const packageJson = require('../../../package.json');

const DEFAULT_USER_AGENT = `${packageJson.name}/${packageJson.version} node/${process.versions.node} ${os.platform()}/${os.release()}`;

const repoUrl = 'https://github.com/okta/okta-sdk-nodejs';

{{#operations}}

/**
 * {{classname}} - request parameter creator{{#description}}
 * {{&description}}{{/description}}
 * @export
 */
export const {{classname}}RequestParamCreator = function (configuration?: Configuration & V2Configuration) {
  const configLoader = new ConfigLoader();
  const clientConfig = Object.assign({}, configuration);
  configLoader.applyDefaults();
  configLoader.apply({
    client: clientConfig || {}
  });

  const parsedConfig = configLoader.config;
  const requestExecutor = clientConfig.requestExecutor || new DefaultRequestExecutor();
  const errors = [];
  if (!parsedConfig.client.orgUrl) {
    errors.push('Okta Org URL not provided');
  }

  if (!parsedConfig.client.token && parsedConfig.client.authorizationMode !== 'PrivateKey') {
    errors.push('Okta API token not provided');
  }

  if (parsedConfig.client.authorizationMode === 'PrivateKey') {
    if (!parsedConfig.client.clientId) {
      errors.push('Okta Client ID not provided');
    }
    if (!parsedConfig.client.scopes) {
      errors.push('Scopes not provided');
    }
    if (!parsedConfig.client.privateKey) {
      errors.push('Private Key not provided');
    }
  } else if (parsedConfig.client.authorizationMode !== 'SSWS') {
    errors.push('Unknown Authorization Mode');
  }
  if (errors.length) {
    throw new Error(`Found ${errors.length} errors:\n${errors.join('\n')}\nSee ${repoUrl} for usage.`);
  }
  const authorizationMode = parsedConfig.client.authorizationMode;
  const baseUrl = parsedConfig.client.orgUrl.replace(/\/$/, '');
  const apiToken = parsedConfig.client.token;

  let clientId;
  let scopes;
  let privateKey;
  let oauth;
  if (authorizationMode === 'PrivateKey') {
    clientId = parsedConfig.client.clientId;
    scopes = parsedConfig.client.scopes.split(' ');
    privateKey = parsedConfig.client.privateKey;
    oauth = new OAuth(this);
  }

  const http: Http = new Http({
    cacheStore: clientConfig.cacheStore,
    cacheMiddleware: clientConfig.cacheMiddleware,
    defaultCacheMiddlewareResponseBufferSize: clientConfig.defaultCacheMiddlewareResponseBufferSize,
    requestExecutor: requestExecutor,
    oauth: oauth
  });
  if (authorizationMode === 'SSWS') {
    http.defaultHeaders.Authorization = `SSWS ${apiToken}`;
  }
  http.defaultHeaders['User-Agent'] = parsedConfig.client.userAgent ? parsedConfig.client.userAgent + ' ' + DEFAULT_USER_AGENT : DEFAULT_USER_AGENT;

    return {
      http,
  {{#operation}}
  {{#contents}}
      /**
        * {{&notes}}
        {{#summary}}
        * @summary {{&summary}}
        {{/summary}}
        {{#parameters}}
        * @param {{braces "left"}}{{dataType}}{{braces "right"}} {{^required}}[{{/required}}{{paramName}}{{^required}}]{{/required}} {{description}}
        {{/parameters}}
        * @param {*} [options] Override http request option.
        * @throws {RequiredError}
        */
      {{nickname}}: ({{#parameters}}{{paramName}}{{^required}}?{{/required}}: {{{dataType}}}, {{/parameters}}options: any = {}): RequestArgs => {
  {{#parameters}}
  {{#required}}
        // verify required parameter '{{paramName}}' is not null or undefined
        if ({{paramName}} === null || {{paramName}} === undefined) {
          throw new RequiredError('{{paramName}}','Required parameter {{paramName}} was null or undefined when calling {{nickname}}.');
        }
  {{/required}}
  {{/parameters}}
          const localVarPath = `{{{path}}}`{{#pathParams}}
              .replace(`{${"{{baseName}}"}}`, encodeURIComponent(String({{paramName}}))){{/pathParams}};
          // use dummy base URL string because the URL constructor only accepts absolute URLs.
          const localVarUrlObj = new URL(localVarPath, 'https://example.com');
          let baseOptions;
          if (configuration) {
            baseOptions = configuration.baseOptions;
          }
          const localVarRequestOptions = { method: '{{httpMethod}}', ...baseOptions, ...options};
          const localVarHeaderParameter = {} as any;
          const localVarQueryParameter = {} as any;{{#vendorExtensions}}{{#hasFormParams}}
          const localVarFormParams = new {{^multipartFormData}}URLSearchParams(){{/multipartFormData}}{{#multipartFormData}}FormData(){{/multipartFormData}};{{/hasFormParams}}{{/vendorExtensions}}

  {{#authMethods}}
          // authentication {{name}} required
          {{#isApiKey}}
          {{#isKeyInHeader}}
          if (configuration && configuration.apiToken) {
            const localVarApiKeyValue = typeof configuration.apiToken === 'function'
                ? configuration.apiToken("{{keyParamName}}")
                : configuration.apiToken;
            localVarHeaderParameter["{{keyParamName}}"] = localVarApiKeyValue;
          }
          {{/isKeyInHeader}}
          {{#isKeyInQuery}}
          if (configuration && configuration.apiToken) {
            const localVarApiKeyValue = typeof configuration.apiToken === 'function'
                ? configuration.apiToken("{{keyParamName}}")
                : configuration.apiToken;
            localVarQueryParameter["{{keyParamName}}"] = localVarApiKeyValue;
          }
          {{/isKeyInQuery}}
          {{/isApiKey}}
          {{#isBasicBasic}}
          // http basic authentication required
          if (configuration && (configuration.username || configuration.password)) {
            localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
          }
          {{/isBasicBasic}}
          {{#isBasicBearer}}
          // http bearer authentication required
          if (configuration && configuration.accessToken) {
            const accessToken = typeof configuration.accessToken === 'function'
                ? configuration.accessToken()
                : configuration.accessToken;
            localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
          }
          {{/isBasicBearer}}
          {{#isOAuth}}
          // oauth required
          if (configuration && configuration.accessToken) {
            const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                ? configuration.accessToken("{{name}}", [{{#each scopes}}"{{@key}}"{{^@last}}, {{/@last}}{{/each}}])
                : configuration.accessToken;
            localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
          }
          {{/isOAuth}}

  {{/authMethods}}
  {{#queryParams}}
          {{#isListContainer}}
          if ({{paramName}}) {
          {{#isCollectionFormatMulti}}
            localVarQueryParameter['{{baseName}}'] = {{paramName}};
          {{/isCollectionFormatMulti}}
          {{^isCollectionFormatMulti}}
            localVarQueryParameter['{{baseName}}'] = {{paramName}}.join(COLLECTION_FORMATS.{{collectionFormat}});
          {{/isCollectionFormatMulti}}
          }
          {{/isListContainer}}
          {{^isListContainer}}
          if ({{paramName}} !== undefined) {
            {{#isDateTime}}
            localVarQueryParameter['{{baseName}}'] = ({{paramName}} as any instanceof Date) ?
                ({{paramName}} as any).toISOString() :
                {{paramName}};
            {{/isDateTime}}
            {{^isDateTime}}
            {{#isDate}}
            localVarQueryParameter['{{baseName}}'] = ({{paramName}} as any instanceof Date) ?
                ({{paramName}} as any).toISOString().substr(0,10) :
                {{paramName}};
            {{/isDate}}
            {{^isDate}}
            localVarQueryParameter['{{baseName}}'] = {{paramName}};
            {{/isDate}}
            {{/isDateTime}}
          }
          {{/isListContainer}}

  {{/queryParams}}
  {{#headerParams}}
          {{#isListContainer}}
          if ({{paramName}}) {
            let mapped = {{paramName}}.map(value => (<any>"{{{dataType}}}" !== "Array<string>") ? JSON.stringify(value) : (value || ""));
            localVarHeaderParameter['{{baseName}}'] = mapped.join(COLLECTION_FORMATS["{{collectionFormat}}"]);
          }
          {{/isListContainer}}
          {{^isListContainer}}
          if ({{paramName}} !== undefined && {{paramName}} !== null) {
            {{#isString}}
            localVarHeaderParameter['{{baseName}}'] = String({{paramName}});
            {{/isString}}
            {{^isString}}
            localVarHeaderParameter['{{baseName}}'] = String(JSON.stringify({{paramName}}));
            {{/isString}}
          }
          {{/isListContainer}}

  {{/headerParams}}
  {{#vendorExtensions}}
  {{#formParams}}
          {{#isListContainer}}
          if ({{paramName}}) {
          {{#isCollectionFormatMulti}}
            {{paramName}}.forEach((element) => {
                localVarFormParams.append('{{baseName}}', element as any);
            })
          {{/isCollectionFormatMulti}}
          {{^isCollectionFormatMulti}}{{^multipartFormData}}
              localVarFormParams.set('{{baseName}}', {{paramName}}.join(COLLECTION_FORMATS.{{collectionFormat}}));{{/multipartFormData}}{{#multipartFormData}}
              localVarFormParams.append('{{baseName}}', {{paramName}}.join(COLLECTION_FORMATS.{{collectionFormat}}));{{/multipartFormData}}
          {{/isCollectionFormatMulti}}
          }{{/isListContainer}}
          {{^isListContainer}}
          if ({{paramName}} !== undefined) { {{^multipartFormData}}
            localVarFormParams.set('{{baseName}}', {{paramName}} as any);{{/multipartFormData}}{{#multipartFormData}}
            localVarFormParams.append('{{baseName}}', {{paramName}} as any);{{/multipartFormData}}
          }
          {{/isListContainer}}
  {{/formParams}}{{/vendorExtensions}}
  {{#vendorExtensions}}{{#hasFormParams}}{{^multipartFormData}}
          localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';{{/multipartFormData}}{{#multipartFormData}}
          localVarHeaderParameter['Content-Type'] = 'multipart/form-data';{{/multipartFormData}}
  {{/hasFormParams}}{{/vendorExtensions}}
  {{#bodyParam}}
          {{^consumes}}
          localVarHeaderParameter['Content-Type'] = 'application/json';
          {{/consumes}}
          {{#consumes.0}}
          localVarHeaderParameter['Content-Type'] = '{{{mediaType}}}';
          {{/consumes.0}}

  {{/bodyParam}}
          const query = new URLSearchParams(localVarUrlObj.search);
          for (const key in localVarQueryParameter) {
            query.set(key, localVarQueryParameter[key]);
          }
          for (const key in options.query) {
            query.set(key, options.query[key]);
          }
          localVarUrlObj.search = (new URLSearchParams(query)).toString();
          let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
          localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
  {{#hasFormParams}}
          localVarRequestOptions.body = localVarFormParams{{#vendorExtensions}}{{^multipartFormData}}.toString(){{/multipartFormData}}{{/vendorExtensions}};
  {{/hasFormParams}}
  {{#bodyParam}}
          const needsSerialization = (typeof {{paramName}} !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
          localVarRequestOptions.body = needsSerialization ? JSON.stringify({{paramName}} !== undefined ? {{paramName}} : {}) : ({{paramName}} || "");
  {{/bodyParam}}

          return {
            url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
            options: localVarRequestOptions,
          };
      },
  {{/contents}}
  {{/operation}}
    }
};

/**
 * {{classname}} - functional programming interface{{#description}}
 * {{{description}}}{{/description}}
 * @export
 */
export const {{classname}}Fp = function(configuration?: Configuration & V2Configuration) {
  return {
    {{#operation}}
    {{#contents}}
    /**
      * {{&notes}}
      {{#summary}}
      * @summary {{&summary}}
      {{/summary}}
      {{#parameters}}
      * @param {{braces "left"}}{{dataType}}{{braces "right"}} {{^required}}[{{/required}}{{paramName}}{{^required}}]{{/required}} {{description}}
      {{/parameters}}
      * @param {*} [options] Override http request option.
      * @throws {RequiredError}
      */
    {{nickname}}({{#parameters}}{{paramName}}{{^required}}?{{/required}}: {{{dataType}}}, {{/parameters}}options?: any): (http?: Http, basePath?: string) => {{#returnType}}{{#eq (substring returnType 0 3) 'Arr'}}Collection<{{{substring returnType 6}}}{{else}}Promise<{{{returnType}}}>{{/eq}}{{/returnType}}{{^returnType}}Promise<Record<string, never>>{{/returnType}} {
      const api = {{classname}}RequestParamCreator(configuration);
      const localVarRequestArgs = api.{{nickname}}({{#parameters}}{{paramName}}, {{/parameters}}options);
      return (http: Http = api.http, basePath: string = configuration.basePath || configuration.orgUrl) => {
        const requestArgs = {...localVarRequestArgs.options, url: basePath + localVarRequestArgs.url};
        {{#returnType}}
        {{#eq (substring returnType 0 3) 'Arr'}}
        return new Collection<{{{substring returnType 6}}}({http}, `${requestArgs.url}`);
        {{else}}
        return http.http(requestArgs.url, requestArgs).then(res => res.json().then((data: {{returnType}}) => data));
        {{/eq}}
        {{/returnType}}
        {{^returnType}}
        return http.http(requestArgs.url, requestArgs).then(resp => {
          return new Promise((resolve, reject) => {
            resp.body.on('data', () => {});
            resp.body.on('error', (err) => reject(err));
            resp.body.on('end', () => resolve({}));
          });
        });
        {{/returnType}}
      }
    },
    {{/contents}}
    {{/operation}}
  }
};

/**
 * {{classname}} - factory interface{{#description}}
 * {{&description}}{{/description}}
 * @export
 */
export const {{classname}}Factory = function (configuration?: Configuration, basePath?: string, http?: Http) {
  return {
    {{#operation}}
    {{#contents}}
    /**
      * {{&notes}}
      {{#summary}}
      * @summary {{&summary}}
      {{/summary}}
      {{#parameters}}
      * @param {{braces "left"}}{{dataType}}{{braces "right"}} {{^required}}[{{/required}}{{paramName}}{{^required}}]{{/required}} {{description}}
      {{/parameters}}
      * @param {*} [options] Override http request option.
      * @throws {RequiredError}
      */
    {{nickname}}({{#parameters}}{{paramName}}{{^required}}?{{/required}}: {{{dataType}}}, {{/parameters}}options?: any): {{#returnType}}{{#eq (substring returnType 0 3) 'Arr'}}Collection<{{{substring returnType 6}}}{{else}}Promise<{{{returnType}}}>{{/eq}}{{/returnType}}{{^returnType}}Promise<Record<string, never>>{{/returnType}} {
      return {{classname}}Fp(configuration).{{nickname}}({{#parameters}}{{paramName}}, {{/parameters}}options)(http, basePath);
    },
    {{/contents}}
    {{/operation}}
  };
};

{{#withInterfaces}}
/**
 * {{classname}} - interface{{#description}}
 * {{&description}}{{/description}}
 * @export
 * @interface {{classname}}
 */
export interface {{classname}}Interface {
{{#operation}}
{{#contents}}
  /**
    * {{&notes}}
    {{#summary}}
    * @summary {{&summary}}
    {{/summary}}
    {{#parameters}}
    * @param {{braces "left"}}{{dataType}}{{braces "right"}} {{^required}}[{{/required}}{{paramName}}{{^required}}]{{/required}} {{description}}
    {{/parameters}}
    * @param {*} [options] Override http request option.
    * @throws {RequiredError}
    * @memberof {{classname}}Interface
    */
  {{nickname}}({{#parameters}}{{paramName}}{{^required}}?{{/required}}: {{{dataType}}}, {{/parameters}}options?: any): Promise<{{#returnType}}{{{returnType}}}{{/returnType}}{{^returnType}}Record<string, never>{{/returnType}}>;

{{/contents}}
{{/operation}}
}

{{/withInterfaces}}
/**
 * {{classname}} - object-oriented interface{{#description}}
 * {{{description}}}{{/description}}
 * @export
 * @class {{classname}}
 * @extends {BaseAPI}
 */
{{#withInterfaces}}
export class {{classname}} extends BaseAPI implements {{classname}}Interface {
{{/withInterfaces}}
{{^withInterfaces}}
export class {{classname}} extends BaseAPI {
{{/withInterfaces}}
  {{#operation}}
  {{#contents}}
  /**
    * {{&notes}}
    {{#summary}}
    * @summary {{&summary}}
    {{/summary}}
    {{#parameters}}
    * @param {{braces "left"}}{{dataType}}{{braces "right"}} {{^required}}[{{/required}}{{paramName}}{{^required}}]{{/required}} {{description}}
    {{/parameters}}
    * @param {*} [options] Override http request option.
    * @throws {RequiredError}
    * @memberof {{classname}}
    */
  public {{nickname}}({{#parameters}}{{paramName}}{{^required}}?{{/required}}: {{{dataType}}}, {{/parameters}}options?: any) {
    return {{classname}}Fp(this.configuration).{{nickname}}({{#parameters}}{{paramName}}, {{/parameters}}options)(this.httpClient, this.basePath);
  }
  {{^@last}}

  {{/@last}}
  {{/contents}}
  {{/operation}}
}
{{/operations}}
