'use strict';
/* tslint:disable */
/* eslint-disable */
/**
 * Copyright (c) 2022-present, Okta, Inc. and/or its affiliates. All rights reserved.
 * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the "License.")
 *
 * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *
 * See the License for the specific language governing permissions and limitations under the License.
 *
 * Okta API
 * Allows customers to easily access the Okta API
 *
 * OpenAPI spec version: 2.10.0
 * Contact: devex-public@okta.com
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.InlineHookApi = exports.InlineHookApiFactory = exports.InlineHookApiFp = exports.InlineHookApiRequestParamCreator = void 0;
// Some imports not used depending on template conditions
// @ts-ignore
const base_1 = require("../base");
const oauth_1 = require("../../oauth");
const http_1 = require("../../http");
const config_loader_1 = require("../../config-loader");
const default_request_executor_1 = require("../../default-request-executor");
const collection_1 = require("../../collection");
const os = require('os');
const packageJson = require('../../../package.json');
const DEFAULT_USER_AGENT = `${packageJson.name}/${packageJson.version} node/${process.versions.node} ${os.platform()}/${os.release()}`;
const repoUrl = 'https://github.com/okta/okta-sdk-nodejs';
/**
 * InlineHookApi - request parameter creator
 * @export
 */
const InlineHookApiRequestParamCreator = function (configuration) {
    const configLoader = new config_loader_1.ConfigLoader();
    const clientConfig = Object.assign({}, configuration);
    configLoader.applyDefaults();
    configLoader.apply({
        client: clientConfig || {}
    });
    const parsedConfig = configLoader.config;
    const requestExecutor = clientConfig.requestExecutor || new default_request_executor_1.DefaultRequestExecutor();
    const errors = [];
    if (!parsedConfig.client.orgUrl) {
        errors.push('Okta Org URL not provided');
    }
    if (!parsedConfig.client.token && parsedConfig.client.authorizationMode !== 'PrivateKey') {
        errors.push('Okta API token not provided');
    }
    if (parsedConfig.client.authorizationMode === 'PrivateKey') {
        if (!parsedConfig.client.clientId) {
            errors.push('Okta Client ID not provided');
        }
        if (!parsedConfig.client.scopes) {
            errors.push('Scopes not provided');
        }
        if (!parsedConfig.client.privateKey) {
            errors.push('Private Key not provided');
        }
    }
    else if (parsedConfig.client.authorizationMode !== 'SSWS') {
        errors.push('Unknown Authorization Mode');
    }
    if (errors.length) {
        throw new Error(`Found ${errors.length} errors:\n${errors.join('\n')}\nSee ${repoUrl} for usage.`);
    }
    const authorizationMode = parsedConfig.client.authorizationMode;
    const baseUrl = parsedConfig.client.orgUrl.replace(/\/$/, '');
    const apiToken = parsedConfig.client.token;
    let clientId;
    let scopes;
    let privateKey;
    let oauth;
    if (authorizationMode === 'PrivateKey') {
        clientId = parsedConfig.client.clientId;
        scopes = parsedConfig.client.scopes.split(' ');
        privateKey = parsedConfig.client.privateKey;
        oauth = new oauth_1.OAuth(this);
    }
    const http = new http_1.Http({
        cacheStore: clientConfig.cacheStore,
        cacheMiddleware: clientConfig.cacheMiddleware,
        defaultCacheMiddlewareResponseBufferSize: clientConfig.defaultCacheMiddlewareResponseBufferSize,
        requestExecutor: requestExecutor,
        oauth: oauth
    });
    if (authorizationMode === 'SSWS') {
        http.defaultHeaders.Authorization = `SSWS ${apiToken}`;
    }
    http.defaultHeaders['User-Agent'] = parsedConfig.client.userAgent ? parsedConfig.client.userAgent + ' ' + DEFAULT_USER_AGENT : DEFAULT_USER_AGENT;
    return {
        http,
        /**
          * Success
          * @summary List Inline Hooks
          * @param {string} [type]
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
        listInlineHooks: (type, options = {}) => {
            const localVarPath = `/api/v1/inlineHooks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_token required
            if (configuration && configuration.apiToken) {
                const localVarApiKeyValue = typeof configuration.apiToken === 'function'
                    ? configuration.apiToken("Authorization")
                    : configuration.apiToken;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("oauth2", ["okta.apps.read", "okta.apps.manage", "okta.authenticators.read", "okta.authenticators.manage", "okta.authorizationServers.read", "okta.authorizationServers.manage", "okta.brands.read", "okta.brands.manage", "okta.captchas.manage", "okta.captchas.read", "okta.domains.read", "okta.domains.manage", "okta.eventHooks.read", "okta.eventHooks.manage", "okta.groups.read", "okta.groups.manage", "okta.roles.read", "okta.roles.manage", "okta.idps.read", "okta.idps.manage", "okta.users.manage", "okta.inlineHooks.read", "okta.inlineHooks.manage", "okta.logs.read", "okta.profileMappings.read", "okta.profileMappings.manage", "okta.schemas.read", "okta.schemas.manage", "okta.linkedObjects.read", "okta.linkedObjects.manage", "okta.userTypes.read", "okta.userTypes.manage", "okta.orgs.read", "okta.orgs.manage", "okta.policies.read", "okta.policies.manage", "okta.sessions.read", "okta.sessions.manage", "okta.templates.read", "okta.templates.manage", "okta.trustedOrigins.read", "okta.trustedOrigins.manage", "okta.users.read.self", "okta.users.read"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
          * Success
          * @summary Create Inline Hook
          * @param {InlineHook} body
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
        createInlineHook: (body, options = {}) => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new base_1.RequiredError('body', 'Required parameter body was null or undefined when calling createInlineHook.');
            }
            const localVarPath = `/api/v1/inlineHooks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_token required
            if (configuration && configuration.apiToken) {
                const localVarApiKeyValue = typeof configuration.apiToken === 'function'
                    ? configuration.apiToken("Authorization")
                    : configuration.apiToken;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("oauth2", ["okta.apps.read", "okta.apps.manage", "okta.authenticators.read", "okta.authenticators.manage", "okta.authorizationServers.read", "okta.authorizationServers.manage", "okta.brands.read", "okta.brands.manage", "okta.captchas.manage", "okta.captchas.read", "okta.domains.read", "okta.domains.manage", "okta.eventHooks.read", "okta.eventHooks.manage", "okta.groups.read", "okta.groups.manage", "okta.roles.read", "okta.roles.manage", "okta.idps.read", "okta.idps.manage", "okta.users.manage", "okta.inlineHooks.read", "okta.inlineHooks.manage", "okta.logs.read", "okta.profileMappings.read", "okta.profileMappings.manage", "okta.schemas.read", "okta.schemas.manage", "okta.linkedObjects.read", "okta.linkedObjects.manage", "okta.userTypes.read", "okta.userTypes.manage", "okta.orgs.read", "okta.orgs.manage", "okta.policies.read", "okta.policies.manage", "okta.sessions.read", "okta.sessions.manage", "okta.templates.read", "okta.templates.manage", "okta.trustedOrigins.read", "okta.trustedOrigins.manage", "okta.users.read.self", "okta.users.read"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
          * Deletes the Inline Hook matching the provided id. Once deleted, the Inline Hook is unrecoverable. As a safety precaution, only Inline Hooks with a status of INACTIVE are eligible for deletion.
          * @summary Delete Inline Hook
          * @param {string} inlineHookId
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
        deleteInlineHook: (inlineHookId, options = {}) => {
            // verify required parameter 'inlineHookId' is not null or undefined
            if (inlineHookId === null || inlineHookId === undefined) {
                throw new base_1.RequiredError('inlineHookId', 'Required parameter inlineHookId was null or undefined when calling deleteInlineHook.');
            }
            const localVarPath = `/api/v1/inlineHooks/{inlineHookId}`
                .replace(`{${"inlineHookId"}}`, encodeURIComponent(String(inlineHookId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_token required
            if (configuration && configuration.apiToken) {
                const localVarApiKeyValue = typeof configuration.apiToken === 'function'
                    ? configuration.apiToken("Authorization")
                    : configuration.apiToken;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("oauth2", ["okta.apps.read", "okta.apps.manage", "okta.authenticators.read", "okta.authenticators.manage", "okta.authorizationServers.read", "okta.authorizationServers.manage", "okta.brands.read", "okta.brands.manage", "okta.captchas.manage", "okta.captchas.read", "okta.domains.read", "okta.domains.manage", "okta.eventHooks.read", "okta.eventHooks.manage", "okta.groups.read", "okta.groups.manage", "okta.roles.read", "okta.roles.manage", "okta.idps.read", "okta.idps.manage", "okta.users.manage", "okta.inlineHooks.read", "okta.inlineHooks.manage", "okta.logs.read", "okta.profileMappings.read", "okta.profileMappings.manage", "okta.schemas.read", "okta.schemas.manage", "okta.linkedObjects.read", "okta.linkedObjects.manage", "okta.userTypes.read", "okta.userTypes.manage", "okta.orgs.read", "okta.orgs.manage", "okta.policies.read", "okta.policies.manage", "okta.sessions.read", "okta.sessions.manage", "okta.templates.read", "okta.templates.manage", "okta.trustedOrigins.read", "okta.trustedOrigins.manage", "okta.users.read.self", "okta.users.read"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
          * Gets an inline hook by ID
          * @summary Get Inline Hook
          * @param {string} inlineHookId
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
        getInlineHook: (inlineHookId, options = {}) => {
            // verify required parameter 'inlineHookId' is not null or undefined
            if (inlineHookId === null || inlineHookId === undefined) {
                throw new base_1.RequiredError('inlineHookId', 'Required parameter inlineHookId was null or undefined when calling getInlineHook.');
            }
            const localVarPath = `/api/v1/inlineHooks/{inlineHookId}`
                .replace(`{${"inlineHookId"}}`, encodeURIComponent(String(inlineHookId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_token required
            if (configuration && configuration.apiToken) {
                const localVarApiKeyValue = typeof configuration.apiToken === 'function'
                    ? configuration.apiToken("Authorization")
                    : configuration.apiToken;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("oauth2", ["okta.apps.read", "okta.apps.manage", "okta.authenticators.read", "okta.authenticators.manage", "okta.authorizationServers.read", "okta.authorizationServers.manage", "okta.brands.read", "okta.brands.manage", "okta.captchas.manage", "okta.captchas.read", "okta.domains.read", "okta.domains.manage", "okta.eventHooks.read", "okta.eventHooks.manage", "okta.groups.read", "okta.groups.manage", "okta.roles.read", "okta.roles.manage", "okta.idps.read", "okta.idps.manage", "okta.users.manage", "okta.inlineHooks.read", "okta.inlineHooks.manage", "okta.logs.read", "okta.profileMappings.read", "okta.profileMappings.manage", "okta.schemas.read", "okta.schemas.manage", "okta.linkedObjects.read", "okta.linkedObjects.manage", "okta.userTypes.read", "okta.userTypes.manage", "okta.orgs.read", "okta.orgs.manage", "okta.policies.read", "okta.policies.manage", "okta.sessions.read", "okta.sessions.manage", "okta.templates.read", "okta.templates.manage", "okta.trustedOrigins.read", "okta.trustedOrigins.manage", "okta.users.read.self", "okta.users.read"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
          * Updates an inline hook by ID
          * @summary Update Inline Hook
          * @param {InlineHook} body
          * @param {string} inlineHookId
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
        updateInlineHook: (body, inlineHookId, options = {}) => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new base_1.RequiredError('body', 'Required parameter body was null or undefined when calling updateInlineHook.');
            }
            // verify required parameter 'inlineHookId' is not null or undefined
            if (inlineHookId === null || inlineHookId === undefined) {
                throw new base_1.RequiredError('inlineHookId', 'Required parameter inlineHookId was null or undefined when calling updateInlineHook.');
            }
            const localVarPath = `/api/v1/inlineHooks/{inlineHookId}`
                .replace(`{${"inlineHookId"}}`, encodeURIComponent(String(inlineHookId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_token required
            if (configuration && configuration.apiToken) {
                const localVarApiKeyValue = typeof configuration.apiToken === 'function'
                    ? configuration.apiToken("Authorization")
                    : configuration.apiToken;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("oauth2", ["okta.apps.read", "okta.apps.manage", "okta.authenticators.read", "okta.authenticators.manage", "okta.authorizationServers.read", "okta.authorizationServers.manage", "okta.brands.read", "okta.brands.manage", "okta.captchas.manage", "okta.captchas.read", "okta.domains.read", "okta.domains.manage", "okta.eventHooks.read", "okta.eventHooks.manage", "okta.groups.read", "okta.groups.manage", "okta.roles.read", "okta.roles.manage", "okta.idps.read", "okta.idps.manage", "okta.users.manage", "okta.inlineHooks.read", "okta.inlineHooks.manage", "okta.logs.read", "okta.profileMappings.read", "okta.profileMappings.manage", "okta.schemas.read", "okta.schemas.manage", "okta.linkedObjects.read", "okta.linkedObjects.manage", "okta.userTypes.read", "okta.userTypes.manage", "okta.orgs.read", "okta.orgs.manage", "okta.policies.read", "okta.policies.manage", "okta.sessions.read", "okta.sessions.manage", "okta.templates.read", "okta.templates.manage", "okta.trustedOrigins.read", "okta.trustedOrigins.manage", "okta.users.read.self", "okta.users.read"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
          * Executes the Inline Hook matching the provided inlineHookId using the request body as the input. This will send the provided data through the Channel and return a response if it matches the correct data contract. This execution endpoint should only be used for testing purposes.
          * @summary Execute Inline Hook
          * @param {InlineHookPayload} body
          * @param {string} inlineHookId
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
        executeInlineHook: (body, inlineHookId, options = {}) => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new base_1.RequiredError('body', 'Required parameter body was null or undefined when calling executeInlineHook.');
            }
            // verify required parameter 'inlineHookId' is not null or undefined
            if (inlineHookId === null || inlineHookId === undefined) {
                throw new base_1.RequiredError('inlineHookId', 'Required parameter inlineHookId was null or undefined when calling executeInlineHook.');
            }
            const localVarPath = `/api/v1/inlineHooks/{inlineHookId}/execute`
                .replace(`{${"inlineHookId"}}`, encodeURIComponent(String(inlineHookId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_token required
            if (configuration && configuration.apiToken) {
                const localVarApiKeyValue = typeof configuration.apiToken === 'function'
                    ? configuration.apiToken("Authorization")
                    : configuration.apiToken;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            // authentication oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("oauth2", ["okta.apps.read", "okta.apps.manage", "okta.authenticators.read", "okta.authenticators.manage", "okta.authorizationServers.read", "okta.authorizationServers.manage", "okta.brands.read", "okta.brands.manage", "okta.captchas.manage", "okta.captchas.read", "okta.domains.read", "okta.domains.manage", "okta.eventHooks.read", "okta.eventHooks.manage", "okta.groups.read", "okta.groups.manage", "okta.roles.read", "okta.roles.manage", "okta.idps.read", "okta.idps.manage", "okta.users.manage", "okta.inlineHooks.read", "okta.inlineHooks.manage", "okta.logs.read", "okta.profileMappings.read", "okta.profileMappings.manage", "okta.schemas.read", "okta.schemas.manage", "okta.linkedObjects.read", "okta.linkedObjects.manage", "okta.userTypes.read", "okta.userTypes.manage", "okta.orgs.read", "okta.orgs.manage", "okta.policies.read", "okta.policies.manage", "okta.sessions.read", "okta.sessions.manage", "okta.templates.read", "okta.templates.manage", "okta.trustedOrigins.read", "okta.trustedOrigins.manage", "okta.users.read.self", "okta.users.read"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
          * Activates the Inline Hook matching the provided id
          * @summary Activate Inline Hook
          * @param {string} inlineHookId
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
        activateInlineHook: (inlineHookId, options = {}) => {
            // verify required parameter 'inlineHookId' is not null or undefined
            if (inlineHookId === null || inlineHookId === undefined) {
                throw new base_1.RequiredError('inlineHookId', 'Required parameter inlineHookId was null or undefined when calling activateInlineHook.');
            }
            const localVarPath = `/api/v1/inlineHooks/{inlineHookId}/lifecycle/activate`
                .replace(`{${"inlineHookId"}}`, encodeURIComponent(String(inlineHookId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
          * Deactivates the Inline Hook matching the provided id
          * @summary Deactivate Inline Hook
          * @param {string} inlineHookId
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
        deactivateInlineHook: (inlineHookId, options = {}) => {
            // verify required parameter 'inlineHookId' is not null or undefined
            if (inlineHookId === null || inlineHookId === undefined) {
                throw new base_1.RequiredError('inlineHookId', 'Required parameter inlineHookId was null or undefined when calling deactivateInlineHook.');
            }
            const localVarPath = `/api/v1/inlineHooks/{inlineHookId}/lifecycle/deactivate`
                .replace(`{${"inlineHookId"}}`, encodeURIComponent(String(inlineHookId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    };
};
exports.InlineHookApiRequestParamCreator = InlineHookApiRequestParamCreator;
/**
 * InlineHookApi - functional programming interface
 * @export
 */
const InlineHookApiFp = function (configuration) {
    return {
        /**
          * Success
          * @summary List Inline Hooks
          * @param {string} [type]
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
        listInlineHooks(type, options) {
            const api = exports.InlineHookApiRequestParamCreator(configuration);
            const localVarRequestArgs = api.listInlineHooks(type, options);
            return (http = api.http, basePath = configuration.basePath || configuration.orgUrl) => {
                const requestArgs = { ...localVarRequestArgs.options, url: basePath + localVarRequestArgs.url };
                return new collection_1.Collection({ http }, `${requestArgs.url}`);
            };
        },
        /**
          * Success
          * @summary Create Inline Hook
          * @param {InlineHook} body
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
        createInlineHook(body, options) {
            const api = exports.InlineHookApiRequestParamCreator(configuration);
            const localVarRequestArgs = api.createInlineHook(body, options);
            return (http = api.http, basePath = configuration.basePath || configuration.orgUrl) => {
                const requestArgs = { ...localVarRequestArgs.options, url: basePath + localVarRequestArgs.url };
                return http.http(requestArgs.url, requestArgs).then(res => res.json().then((data) => data));
            };
        },
        /**
          * Deletes the Inline Hook matching the provided id. Once deleted, the Inline Hook is unrecoverable. As a safety precaution, only Inline Hooks with a status of INACTIVE are eligible for deletion.
          * @summary Delete Inline Hook
          * @param {string} inlineHookId
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
        deleteInlineHook(inlineHookId, options) {
            const api = exports.InlineHookApiRequestParamCreator(configuration);
            const localVarRequestArgs = api.deleteInlineHook(inlineHookId, options);
            return (http = api.http, basePath = configuration.basePath || configuration.orgUrl) => {
                const requestArgs = { ...localVarRequestArgs.options, url: basePath + localVarRequestArgs.url };
                return http.http(requestArgs.url, requestArgs).then(resp => {
                    return new Promise((resolve, reject) => {
                        resp.body.on('data', () => { });
                        resp.body.on('error', (err) => reject(err));
                        resp.body.on('end', () => resolve({}));
                    });
                });
            };
        },
        /**
          * Gets an inline hook by ID
          * @summary Get Inline Hook
          * @param {string} inlineHookId
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
        getInlineHook(inlineHookId, options) {
            const api = exports.InlineHookApiRequestParamCreator(configuration);
            const localVarRequestArgs = api.getInlineHook(inlineHookId, options);
            return (http = api.http, basePath = configuration.basePath || configuration.orgUrl) => {
                const requestArgs = { ...localVarRequestArgs.options, url: basePath + localVarRequestArgs.url };
                return http.http(requestArgs.url, requestArgs).then(res => res.json().then((data) => data));
            };
        },
        /**
          * Updates an inline hook by ID
          * @summary Update Inline Hook
          * @param {InlineHook} body
          * @param {string} inlineHookId
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
        updateInlineHook(body, inlineHookId, options) {
            const api = exports.InlineHookApiRequestParamCreator(configuration);
            const localVarRequestArgs = api.updateInlineHook(body, inlineHookId, options);
            return (http = api.http, basePath = configuration.basePath || configuration.orgUrl) => {
                const requestArgs = { ...localVarRequestArgs.options, url: basePath + localVarRequestArgs.url };
                return http.http(requestArgs.url, requestArgs).then(res => res.json().then((data) => data));
            };
        },
        /**
          * Executes the Inline Hook matching the provided inlineHookId using the request body as the input. This will send the provided data through the Channel and return a response if it matches the correct data contract. This execution endpoint should only be used for testing purposes.
          * @summary Execute Inline Hook
          * @param {InlineHookPayload} body
          * @param {string} inlineHookId
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
        executeInlineHook(body, inlineHookId, options) {
            const api = exports.InlineHookApiRequestParamCreator(configuration);
            const localVarRequestArgs = api.executeInlineHook(body, inlineHookId, options);
            return (http = api.http, basePath = configuration.basePath || configuration.orgUrl) => {
                const requestArgs = { ...localVarRequestArgs.options, url: basePath + localVarRequestArgs.url };
                return http.http(requestArgs.url, requestArgs).then(res => res.json().then((data) => data));
            };
        },
        /**
          * Activates the Inline Hook matching the provided id
          * @summary Activate Inline Hook
          * @param {string} inlineHookId
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
        activateInlineHook(inlineHookId, options) {
            const api = exports.InlineHookApiRequestParamCreator(configuration);
            const localVarRequestArgs = api.activateInlineHook(inlineHookId, options);
            return (http = api.http, basePath = configuration.basePath || configuration.orgUrl) => {
                const requestArgs = { ...localVarRequestArgs.options, url: basePath + localVarRequestArgs.url };
                return http.http(requestArgs.url, requestArgs).then(res => res.json().then((data) => data));
            };
        },
        /**
          * Deactivates the Inline Hook matching the provided id
          * @summary Deactivate Inline Hook
          * @param {string} inlineHookId
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
        deactivateInlineHook(inlineHookId, options) {
            const api = exports.InlineHookApiRequestParamCreator(configuration);
            const localVarRequestArgs = api.deactivateInlineHook(inlineHookId, options);
            return (http = api.http, basePath = configuration.basePath || configuration.orgUrl) => {
                const requestArgs = { ...localVarRequestArgs.options, url: basePath + localVarRequestArgs.url };
                return http.http(requestArgs.url, requestArgs).then(res => res.json().then((data) => data));
            };
        },
    };
};
exports.InlineHookApiFp = InlineHookApiFp;
/**
 * InlineHookApi - factory interface
 * @export
 */
const InlineHookApiFactory = function (configuration, basePath, http) {
    return {
        /**
          * Success
          * @summary List Inline Hooks
          * @param {string} [type]
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
        listInlineHooks(type, options) {
            return exports.InlineHookApiFp(configuration).listInlineHooks(type, options)(http, basePath);
        },
        /**
          * Success
          * @summary Create Inline Hook
          * @param {InlineHook} body
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
        createInlineHook(body, options) {
            return exports.InlineHookApiFp(configuration).createInlineHook(body, options)(http, basePath);
        },
        /**
          * Deletes the Inline Hook matching the provided id. Once deleted, the Inline Hook is unrecoverable. As a safety precaution, only Inline Hooks with a status of INACTIVE are eligible for deletion.
          * @summary Delete Inline Hook
          * @param {string} inlineHookId
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
        deleteInlineHook(inlineHookId, options) {
            return exports.InlineHookApiFp(configuration).deleteInlineHook(inlineHookId, options)(http, basePath);
        },
        /**
          * Gets an inline hook by ID
          * @summary Get Inline Hook
          * @param {string} inlineHookId
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
        getInlineHook(inlineHookId, options) {
            return exports.InlineHookApiFp(configuration).getInlineHook(inlineHookId, options)(http, basePath);
        },
        /**
          * Updates an inline hook by ID
          * @summary Update Inline Hook
          * @param {InlineHook} body
          * @param {string} inlineHookId
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
        updateInlineHook(body, inlineHookId, options) {
            return exports.InlineHookApiFp(configuration).updateInlineHook(body, inlineHookId, options)(http, basePath);
        },
        /**
          * Executes the Inline Hook matching the provided inlineHookId using the request body as the input. This will send the provided data through the Channel and return a response if it matches the correct data contract. This execution endpoint should only be used for testing purposes.
          * @summary Execute Inline Hook
          * @param {InlineHookPayload} body
          * @param {string} inlineHookId
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
        executeInlineHook(body, inlineHookId, options) {
            return exports.InlineHookApiFp(configuration).executeInlineHook(body, inlineHookId, options)(http, basePath);
        },
        /**
          * Activates the Inline Hook matching the provided id
          * @summary Activate Inline Hook
          * @param {string} inlineHookId
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
        activateInlineHook(inlineHookId, options) {
            return exports.InlineHookApiFp(configuration).activateInlineHook(inlineHookId, options)(http, basePath);
        },
        /**
          * Deactivates the Inline Hook matching the provided id
          * @summary Deactivate Inline Hook
          * @param {string} inlineHookId
          * @param {*} [options] Override http request option.
          * @throws {RequiredError}
          */
        deactivateInlineHook(inlineHookId, options) {
            return exports.InlineHookApiFp(configuration).deactivateInlineHook(inlineHookId, options)(http, basePath);
        },
    };
};
exports.InlineHookApiFactory = InlineHookApiFactory;
/**
 * InlineHookApi - object-oriented interface
 * @export
 * @class InlineHookApi
 * @extends {BaseAPI}
 */
class InlineHookApi extends base_1.BaseAPI {
    /**
      * Success
      * @summary List Inline Hooks
      * @param {string} [type]
      * @param {*} [options] Override http request option.
      * @throws {RequiredError}
      * @memberof InlineHookApi
      */
    listInlineHooks(type, options) {
        return exports.InlineHookApiFp(this.configuration).listInlineHooks(type, options)(this.httpClient, this.basePath);
    }
    /**
      * Success
      * @summary Create Inline Hook
      * @param {InlineHook} body
      * @param {*} [options] Override http request option.
      * @throws {RequiredError}
      * @memberof InlineHookApi
      */
    createInlineHook(body, options) {
        return exports.InlineHookApiFp(this.configuration).createInlineHook(body, options)(this.httpClient, this.basePath);
    }
    /**
      * Deletes the Inline Hook matching the provided id. Once deleted, the Inline Hook is unrecoverable. As a safety precaution, only Inline Hooks with a status of INACTIVE are eligible for deletion.
      * @summary Delete Inline Hook
      * @param {string} inlineHookId
      * @param {*} [options] Override http request option.
      * @throws {RequiredError}
      * @memberof InlineHookApi
      */
    deleteInlineHook(inlineHookId, options) {
        return exports.InlineHookApiFp(this.configuration).deleteInlineHook(inlineHookId, options)(this.httpClient, this.basePath);
    }
    /**
      * Gets an inline hook by ID
      * @summary Get Inline Hook
      * @param {string} inlineHookId
      * @param {*} [options] Override http request option.
      * @throws {RequiredError}
      * @memberof InlineHookApi
      */
    getInlineHook(inlineHookId, options) {
        return exports.InlineHookApiFp(this.configuration).getInlineHook(inlineHookId, options)(this.httpClient, this.basePath);
    }
    /**
      * Updates an inline hook by ID
      * @summary Update Inline Hook
      * @param {InlineHook} body
      * @param {string} inlineHookId
      * @param {*} [options] Override http request option.
      * @throws {RequiredError}
      * @memberof InlineHookApi
      */
    updateInlineHook(body, inlineHookId, options) {
        return exports.InlineHookApiFp(this.configuration).updateInlineHook(body, inlineHookId, options)(this.httpClient, this.basePath);
    }
    /**
      * Executes the Inline Hook matching the provided inlineHookId using the request body as the input. This will send the provided data through the Channel and return a response if it matches the correct data contract. This execution endpoint should only be used for testing purposes.
      * @summary Execute Inline Hook
      * @param {InlineHookPayload} body
      * @param {string} inlineHookId
      * @param {*} [options] Override http request option.
      * @throws {RequiredError}
      * @memberof InlineHookApi
      */
    executeInlineHook(body, inlineHookId, options) {
        return exports.InlineHookApiFp(this.configuration).executeInlineHook(body, inlineHookId, options)(this.httpClient, this.basePath);
    }
    /**
      * Activates the Inline Hook matching the provided id
      * @summary Activate Inline Hook
      * @param {string} inlineHookId
      * @param {*} [options] Override http request option.
      * @throws {RequiredError}
      * @memberof InlineHookApi
      */
    activateInlineHook(inlineHookId, options) {
        return exports.InlineHookApiFp(this.configuration).activateInlineHook(inlineHookId, options)(this.httpClient, this.basePath);
    }
    /**
      * Deactivates the Inline Hook matching the provided id
      * @summary Deactivate Inline Hook
      * @param {string} inlineHookId
      * @param {*} [options] Override http request option.
      * @throws {RequiredError}
      * @memberof InlineHookApi
      */
    deactivateInlineHook(inlineHookId, options) {
        return exports.InlineHookApiFp(this.configuration).deactivateInlineHook(inlineHookId, options)(this.httpClient, this.basePath);
    }
}
exports.InlineHookApi = InlineHookApi;
